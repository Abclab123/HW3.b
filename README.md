# Team 6, module 8
## Environment
```bash
conda create -n tts python=3.12

conda activate tts

pip install -r requirements.txt
```
Because the `gtts` package can adapt to various Python versions and supports multiple languages, we chose the gtts package to convert text into speech.

- `gtts` support python version 3.8-3.12
- `gtts` support following languages:
    ```python
    {'af': 'Afrikaans', 'ar': 'Arabic', 'bg': 'Bulgarian', 'bn': 'Bengali', 'bs': 'Bosnian', 'ca': 'Catalan', 'cs': 'Czech', 'cy': 'Welsh', 'da': 'Danish', 'de': 'German', 'el': 'Greek', 'en': 'English', 'eo': 'Esperanto', 'es': 'Spanish', 'et': 'Estonian', 'fi': 'Finnish', 'fr': 'French', 'gu': 'Gujarati', 'hi': 'Hindi', 'hr': 'Croatian', 'hu': 'Hungarian', 'hy': 'Armenian', 'id': 'Indonesian', 'is': 'Icelandic', 'it': 'Italian', 'iw': 'Hebrew', 'ja': 'Japanese', 'jw': 'Javanese', 'km': 'Khmer', 'kn': 'Kannada', 'ko': 'Korean', 'la': 'Latin', 'lv': 'Latvian', 'mk': 'Macedonian', 'ms': 'Malay', 'ml': 'Malayalam', 'mr': 'Marathi', 'my': 'Myanmar (Burmese)', 'ne': 'Nepali', 'nl': 'Dutch', 'no': 'Norwegian', 'pl': 'Polish', 'pt': 'Portuguese', 'ro': 'Romanian', 'ru': 'Russian', 'si': 'Sinhala', 'sk': 'Slovak', 'sq': 'Albanian', 'sr': 'Serbian', 'su': 'Sundanese', 'sv': 'Swedish', 'sw': 'Swahili', 'ta': 'Tamil', 'te': 'Telugu', 'th': 'Thai', 'tl': 'Filipino', 'tr': 'Turkish', 'uk': 'Ukrainian', 'ur': 'Urdu', 'vi': 'Vietnamese', 'zh-CN': 'Chinese', 'zh-TW': 'Chinese (Mandarin/Taiwan)', 'zh': 'Chinese (Mandarin)'}
    ```
- `0.mp3` is the audio file generated by the gtts package with only `English` text
- `1.mp3` is the audio file generated by the gtts package with only `Chinese` text
- `2.mp3` is the audio file generated by the gtts package with `English` and `Chinese` text.

From the example above, it is evident that we performs well in selecting a suitable storytelling package and demonstrates diligence and seriousness in our efforts.


## Original README.md
```
# Project Name: GenAI Toolbox

## 1: Generative AI, aka GenAI
Invoke #6 and #7 to generate texts and images respectively.

UI_gen

## 2: UI for reading aloud the generated text.

UI_read

## 3: Search the vector store

UI_search

## 4: UI for login.

UI login

## 5

class speech_to_text:
    def __init__(self, online: bool, language: str):
        self.online = online
        self.language = language

    def record(self, output_file_id: int) -> str:
        if self.online:
            pass
        else:
            pass

## 6
# In this module, your input arguments are user's prompt and the chat history, and the goal is to generate good stories by using openai api.
# Utilize the system prompt to ingeniously guide your GPT in crafting a creative narrative with a compelling plot twist.

class OpenAIGenerator:
    def __init__(self, api_key: str):
        openai.api_key = api_key

    def generate(self, user_input: str, history: list = []) -> str:
        pass

## 7

from torch import autocast
from diffusers import StableDiffusionPipeline

class ImageGenerator:
    def __init__(self, model_name: str, online: bool):
        pass

    def generate_image(self, prompt, output_file_id: int):
        pass

## 8

class TextToSpeech:
    def __init__(self, language: str):
        self.language = language

    def convert_to_audio(self, text, file_id: int):
        pass

## 9
# In this module, you need to use mongoDB to create a database for books.
# Each book has its corresponding table.
# The format of the elements of the collections are : {page : page_number, content : the text content of this page, picture_idx : the index of the picture corresponding to the story in this page.}
# MongoDB
import pymongo

class BooksDB:
    def __init__(self, myclient: str):
        self.myclient = myclient
        self.mydb = myclient["mydatabase"]

    def create_book(self, bookname: str):
        pass

    def append(bookname: str, picture_idx: int, content: str):
        pass

    def get_book_content(bookname:str):
        #return a list of dictionaries [{page : page_number, content:"page 0 text",pic_id: page 0 picture id(int)},{page : page_number, content:"page 1 text",pic_id: page 1 picture id(int)},{page : page_number, content:"page 2 text",pic_id: page 2 picture id(int)},...]
        pass

## 10

class PineconeInterface:
    def __init__(self, api_key, index_name):
        pinecone.init(api_key=api_key)
        self.index = pinecone.Index(index_name)

    def insert_vector(self, book_id, book_data):
        #Do embedding here!
        self.index.upsert(items=[(vector_id, vector_data)])

    def search_vectors(self, query_vector, top_k=5):
        pass

## 11: Putting it all together.

## 12: Fine-tune

## 13: Prepare data
```
